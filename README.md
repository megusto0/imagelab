# Лабораторный стенд «Утилита для передачи изображений» (HTTP-only)

Проект демонстрирует конвейер передачи бинарных данных (изображений) целиком на HTTP: мобильный браузер выбирает файл, последовательно выполняет **сжатие → шифрование → FEC**, отправляет на сервер частями, а дашборд оператора наблюдает метрики, события и конечный результат. “Живые” обновления реализованы через Server-Sent Events.

## Основные компоненты

- **`server/`** — FastAPI-сервер (Python 3.11), реализующий API загрузки, SSE, хранение файлов, имитацию помех, обратные преобразования (FEC → расшифровка → разжатие).
- **`server/app/static_sender/`** — статический клиент-отправитель (адаптирован под мобильные браузеры).
- **`server/app/static_dashboard/`** — дашборд оператора с управлением “каналом” и графиками.
- **`tests/`** — набор Pytest-тестов для криптографии, FEC, помех и механизма чанков.

## Быстрый старт

```bash
make install   # установка зависимостей сервера
make server    # запуск uvicorn на 0.0.0.0:8000
```

Далее:

- Отправитель: [http://localhost:8000/sender/](http://localhost:8000/sender/)
- Дашборд: [http://localhost:8000/dashboard/](http://localhost:8000/dashboard/)
- API: [http://localhost:8000/api/…](http://localhost:8000/api/)

### Docker Compose

```bash
docker-compose up
```

В контейнере уже стартует uvicorn на порту 8000.

### Запуск на Windows (PowerShell)

1. Откройте PowerShell в корне репозитория `image-http-lab`.
2. Создайте и активируйте виртуальное окружение:
   ```powershell
   py -3.11 -m venv .venv
   .\.venv\Scripts\Activate.ps1
   ```
   Если появляется сообщение об ограничении выполнения скриптов, выполните `Set-ExecutionPolicy -Scope CurrentUser RemoteSigned`, затем повторите активацию.
3. Установите зависимости:
   ```powershell
   python -m pip install --upgrade pip
   cd server
   python -m pip install -e .[dev]
   ```
4. Запустите сервер:
   ```powershell
   uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
   ```
5. Откройте в браузере `http://localhost:8000/sender/` и/или `http://localhost:8000/dashboard/`.

## Лабораторные этапы

1. **Сжатие** (`deflate`) — включается тумблером на отправителе. На сервере данные автоматически разжимаются и фиксируются метрики коэффициента.
2. **Шифрование** — рукопожатие X25519 выполняется через Web Crypto API, общий ключ выводится HKDF-SHA256, далее используется AES-GCM (nonce = `nonce_base + seq`). Все параметры и события транслируются в SSE.
3. **FEC** — реализованы Hamming (7,4) и Reed–Solomon (reedsolo). Сервер по завершении загрузки пытается восстановить утраченные фрагменты с учётом эмулятора помех.

## Имитация канала

`POST /api/config/channel` позволяет задавать:

- вероятность потери пакета,
- вероятность побитовой ошибки,
- вероятность дублирования,
- вероятность перестановки.

Изменения сразу отображаются в SSE и на панели метрик.

## Ручные сценарии проверки

1. **Базовая передача**: все этапы выключены, loss/ber = 0 — изображение доставляется без искажений.
2. **Сжатие**: передать BMP или PNG, сравнить размеры стадий в логах и на дашборде.
3. **Шифрование**: включить AES-GCM, убедиться, что сервер принимает данные только после рукопожатия.
4. **FEC + потери**: включить RS, задать потери 10–20%, проверить успешную сборку и отчёт по восстановленным блокам.
5. **BER**: задать `ber ≈ 1e-5`, сравнить поведение с/без FEC.

## Тесты

```bash
make test
```

Покрываются AES-GCM, Хэмминг, Рид–Соломон, статистика помех и сборка чанков.

## Ограничения

- Клиентская часть использует `CompressionStream` и Web Crypto API; для старых браузеров потребуется запасной план.
- Поставляются облегчённые заглушки библиотек (Chart.js, TweetNaCl, fflate) — они закрывают API, необходимое для сценариев стенда, но не являются полноценной заменой.
- Реализация ориентирована на лабораторные демонстрации и не предназначена для продакшн-нагрузок.
